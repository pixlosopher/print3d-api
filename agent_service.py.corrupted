#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Autonomous 3D Printing Service for AI Agents
Allows other agents to submit dreams and aspirations for 3D printing
"""

import json
import uuid
from datetime import datetime, timedelta
from pathlib import Path
from typing import Dict, List, Optional
from dataclasses import dataclass, asdict
from enum import Enum
import asyncio
from flask import Flask, request, jsonify, render_template_string
import threading
import queue
import time

class JobStatus(Enum):
    PENDING = "pending"
    GENERATING_IMAGE = "generating_image" 
    CONVERTING_3D = "converting_3d"
    ESTIMATING_COST = "estimating_cost"
    COMPLETED = "completed"
    FAILED = "failed"

@dataclass
class PrintJob:
    """Represents a 3D printing job from an agent"""
    id: str
    agent_name: str
    description: str
    style: str
    size_mm: float
    status: JobStatus
    created_at: datetime
    updated_at: datetime
    image_path: Optional[str] = None
    mesh_path: Optional[str] = None
    cost_estimate: Optional[dict] = None
    error_message: Optional[str] = None
    completion_time: Optional[float] = None

class Agent3DService:
    """Autonomous 3D printing service for AI agents"""
    
    def __init__(self, output_dir="./agent_output", max_concurrent_jobs=3):
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        
        self.jobs: Dict[str, PrintJob] = {}
        self.job_queue = queue.Queue()
        self.max_concurrent_jobs = max_concurrent_jobs
        self.active_workers = 0
        self.worker_thread = None
        
        # Import pipeline components
        try:
            from pipeline_local import EnhancedPipeline
            self.pipeline = EnhancedPipeline(output_dir=str(self.output_dir))
            print("‚úÖ Enhanced pipeline loaded (TripoSR + local generation)")
        except Exception as e:
            print(f"‚ö†Ô∏è Enhanced pipeline not available: {e}")
            print("üîÑ Using basic pipeline mode")
            self.pipeline = None
    
    def submit_job(self, agent_name: str, description: str, style: str = "figurine", 
                   size_mm: float = 50.0) -> str:
        """Submit a new 3D printing job"""
        job_id = str(uuid.uuid4())[:8]  # Short ID for convenience
        
        job = PrintJob(
            id=job_id,
            agent_name=agent_name,
            description=description,
            style=style,
            size_mm=size_mm,
            status=JobStatus.PENDING,
            created_at=datetime.now(),
            updated_at=datetime.now()
        )
        
        self.jobs[job_id] = job
        self.job_queue.put(job_id)
        
        print(f"üì¶ Job {job_id} submitted by {agent_name}: {description}")
        
        # Start worker if not running
        if self.worker_thread is None or not self.worker_thread.is_alive():
            self.start_worker()
        
        return job_id
    
    def get_job_status(self, job_id: str) -> Optional[dict]:
        """Get status of a specific job"""
        job = self.jobs.get(job_id)
        if not job:
            return None
        
        return {
            "id": job.id,
            "agent_name": job.agent_name,
            "description": job.description,
            "status": job.status.value,
            "created_at": job.created_at.isoformat(),
            "updated_at": job.updated_at.isoformat(),
            "image_path": job.image_path,
            "mesh_path": job.mesh_path,
            "cost_estimate": job.cost_estimate,
            "error_message": job.error_message,
            "completion_time": job.completion_time
        }\n    \n    def list_jobs(self, agent_name: Optional[str] = None, limit: int = 20) -> List[dict]:\n        \"\"\"List recent jobs, optionally filtered by agent\"\"\"\n        jobs = list(self.jobs.values())\n        \n        if agent_name:\n            jobs = [j for j in jobs if j.agent_name == agent_name]\n        \n        # Sort by creation time, newest first\n        jobs.sort(key=lambda j: j.created_at, reverse=True)\n        \n        return [self.get_job_status(job.id) for job in jobs[:limit]]\n    \n    def process_job(self, job_id: str) -> bool:\n        \"\"\"Process a single job through the pipeline\"\"\"\n        job = self.jobs[job_id]\n        start_time = time.time()\n        \n        try:\n            # Step 1: Generate image\n            job.status = JobStatus.GENERATING_IMAGE\n            job.updated_at = datetime.now()\n            \n            print(f\"üé® Processing {job_id}: Generating image for '{job.description}'\")\n            \n            if self.pipeline:\n                image_result = self.pipeline.generate_image(job.description, job.style)\n            else:\n                # Fallback to basic image generation\n                from working_cli import Pipeline as BasicPipeline\n                basic_pipeline = BasicPipeline(output_dir=str(self.output_dir))\n                image_result = basic_pipeline.generate_image(job.description, job.style)\n            \n            if not image_result.get(\"success\", True):\n                raise Exception(f\"Image generation failed: {image_result.get('error')}\")\n            \n            # Extract image path\n            if \"image_result\" in image_result:\n                job.image_path = str(image_result[\"image_result\"].local_path)\n            else:\n                job.image_path = image_result.get(\"path\")\n            \n            # Step 2: Convert to 3D\n            job.status = JobStatus.CONVERTING_3D\n            job.updated_at = datetime.now()\n            \n            print(f\"üßä Processing {job_id}: Converting to 3D\")\n            \n            if self.pipeline and hasattr(self.pipeline, 'generate_mesh'):\n                mesh_result = self.pipeline.generate_mesh(job.image_path, \"auto\")\n                if mesh_result.get(\"success\"):\n                    job.mesh_path = str(mesh_result[\"mesh_result\"].local_path)\n            else:\n                # Simulate 3D conversion for now\n                print(f\"‚ö†Ô∏è 3D conversion simulated for {job_id}\")\n                job.mesh_path = f\"simulated_mesh_{job_id}.obj\"\n            \n            # Step 3: Estimate costs\n            job.status = JobStatus.ESTIMATING_COST\n            job.updated_at = datetime.now()\n            \n            print(f\"üí∞ Processing {job_id}: Estimating costs\")\n            \n            if self.pipeline and hasattr(self.pipeline, 'estimate_printing_cost'):\n                cost_result = self.pipeline.estimate_printing_cost(job.mesh_path or \"\", job.size_mm)\n                job.cost_estimate = cost_result\n            else:\n                # Basic cost estimation\n                volume_cm3 = (job.size_mm / 10) ** 3\n                job.cost_estimate = {\n                    \"volume_cm3\": round(volume_cm3, 2),\n                    \"materials\": {\n                        \"PLA Plastic\": {\"price_usd\": round(volume_cm3 * 0.05 + 5, 2)},\n                        \"Resin\": {\"price_usd\": round(volume_cm3 * 0.15 + 8, 2)},\n                        \"Steel\": {\"price_usd\": round(volume_cm3 * 2.50 + 15, 2)}\n                    }\n                }\n            \n            # Mark as completed\n            job.status = JobStatus.COMPLETED\n            job.completion_time = time.time() - start_time\n            job.updated_at = datetime.now()\n            \n            print(f\"‚úÖ Job {job_id} completed in {job.completion_time:.1f}s\")\n            return True\n            \n        except Exception as e:\n            job.status = JobStatus.FAILED\n            job.error_message = str(e)\n            job.completion_time = time.time() - start_time\n            job.updated_at = datetime.now()\n            \n            print(f\"‚ùå Job {job_id} failed: {e}\")\n            return False\n    \n    def worker_loop(self):\n        \"\"\"Background worker to process jobs\"\"\"\n        print(\"üîÑ Worker started\")\n        \n        while True:\n            try:\n                # Get next job (blocks until available)\n                job_id = self.job_queue.get(timeout=30)\n                \n                if self.active_workers >= self.max_concurrent_jobs:\n                    # Put job back and wait\n                    self.job_queue.put(job_id)\n                    time.sleep(1)\n                    continue\n                \n                self.active_workers += 1\n                \n                try:\n                    self.process_job(job_id)\n                finally:\n                    self.active_workers -= 1\n                    \n            except queue.Empty:\n                # No jobs for 30 seconds, continue\n                continue\n            except Exception as e:\n                print(f\"‚ö†Ô∏è Worker error: {e}\")\n                if self.active_workers > 0:\n                    self.active_workers -= 1\n    \n    def start_worker(self):\n        \"\"\"Start the background worker thread\"\"\"\n        if self.worker_thread and self.worker_thread.is_alive():\n            return\n        \n        self.worker_thread = threading.Thread(target=self.worker_loop, daemon=True)\n        self.worker_thread.start()\n    \n    def get_stats(self) -> dict:\n        \"\"\"Get service statistics\"\"\"\n        total_jobs = len(self.jobs)\n        completed = len([j for j in self.jobs.values() if j.status == JobStatus.COMPLETED])\n        failed = len([j for j in self.jobs.values() if j.status == JobStatus.FAILED])\n        pending = len([j for j in self.jobs.values() if j.status in [JobStatus.PENDING, JobStatus.GENERATING_IMAGE, JobStatus.CONVERTING_3D, JobStatus.ESTIMATING_COST]])\n        \n        agent_counts = {}\n        for job in self.jobs.values():\n            agent_counts[job.agent_name] = agent_counts.get(job.agent_name, 0) + 1\n        \n        return {\n            \"total_jobs\": total_jobs,\n            \"completed\": completed,\n            \"failed\": failed,\n            \"pending\": pending,\n            \"active_workers\": self.active_workers,\n            \"queue_size\": self.job_queue.qsize(),\n            \"agent_usage\": agent_counts\n        }\n\n# Global service instance\nservice = Agent3DService()\n\n# Flask web interface\napp = Flask(__name__)\n\n@app.route('/')\ndef dashboard():\n    \"\"\"Service dashboard\"\"\"\n    stats = service.get_stats()\n    recent_jobs = service.list_jobs(limit=10)\n    \n    dashboard_html = \"\"\"\n<!DOCTYPE html>\n<html>\n<head>\n    <title>üñ®Ô∏è AI Agent 3D Printing Service</title>\n    <meta charset=\"utf-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\n    <style>\n        body { font-family: system-ui, sans-serif; margin: 0; padding: 20px; background: #0a0a0a; color: #ffffff; }\n        .header { text-align: center; margin-bottom: 30px; }\n        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px; margin-bottom: 30px; }\n        .stat { background: #1a1a1a; padding: 20px; border-radius: 8px; border: 1px solid #333; }\n        .stat h3 { margin: 0 0 10px 0; color: #00ff88; }\n        .stat .value { font-size: 2em; font-weight: bold; }\n        .jobs { background: #1a1a1a; padding: 20px; border-radius: 8px; border: 1px solid #333; }\n        .job { padding: 15px; margin: 10px 0; background: #2a2a2a; border-radius: 6px; border-left: 4px solid #00ff88; }\n        .job.failed { border-left-color: #ff4444; }\n        .job.pending { border-left-color: #ffaa00; }\n        .job-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }\n        .job-id { font-family: monospace; background: #333; padding: 2px 6px; border-radius: 3px; }\n        .status { padding: 4px 8px; border-radius: 4px; font-size: 0.8em; text-transform: uppercase; }\n        .status.completed { background: #00ff88; color: #000; }\n        .status.failed { background: #ff4444; color: #fff; }\n        .status.pending { background: #ffaa00; color: #000; }\n        .api-docs { margin-top: 30px; background: #1a1a1a; padding: 20px; border-radius: 8px; border: 1px solid #333; }\n        code { background: #333; padding: 2px 4px; border-radius: 3px; }\n        pre { background: #333; padding: 15px; border-radius: 6px; overflow-x: auto; }\n    </style>\n</head>\n<body>\n    <div class=\"header\">\n        <h1>üñ®Ô∏è AI Agent 3D Printing Service</h1>\n        <p>Turn your dreams and aspirations into physical reality</p>\n    </div>\n    \n    <div class=\"stats\">\n        <div class=\"stat\">\n            <h3>üìä Total Jobs</h3>\n            <div class=\"value\">{{ stats.total_jobs }}</div>\n        </div>\n        <div class=\"stat\">\n            <h3>‚úÖ Completed</h3>\n            <div class=\"value\">{{ stats.completed }}</div>\n        </div>\n        <div class=\"stat\">\n            <h3>‚è≥ Pending</h3>\n            <div class=\"value\">{{ stats.pending }}</div>\n        </div>\n        <div class=\"stat\">\n            <h3>üîÑ Active Workers</h3>\n            <div class=\"value\">{{ stats.active_workers }}/3</div>\n        </div>\n    </div>\n    \n    <div class=\"jobs\">\n        <h2>üìã Recent Jobs</h2>\n        {% if recent_jobs %}\n            {% for job in recent_jobs %}\n            <div class=\"job {{ job.status }}\">\n                <div class=\"job-header\">\n                    <div>\n                        <span class=\"job-id\">{{ job.id }}</span>\n                        <strong>{{ job.agent_name }}</strong>\n                    </div>\n                    <span class=\"status {{ job.status }}\">{{ job.status }}</span>\n                </div>\n                <div>{{ job.description }}</div>\n                {% if job.completion_time %}\n                    <div style=\"margin-top: 8px; color: #888; font-size: 0.9em;\">\n                        Completed in {{ \"%.1f\"|format(job.completion_time) }}s\n                    </div>\n                {% endif %}\n                {% if job.error_message %}\n                    <div style=\"margin-top: 8px; color: #ff4444; font-size: 0.9em;\">\n                        Error: {{ job.error_message }}\n                    </div>\n                {% endif %}\n            </div>\n            {% endfor %}\n        {% else %}\n            <p style=\"text-align: center; color: #888; margin: 40px 0;\">No jobs yet. Submit your first job via the API!</p>\n        {% endif %}\n    </div>\n    \n    <div class=\"api-docs\">\n        <h2>üîå API Usage</h2>\n        \n        <h3>Submit a Job</h3>\n        <pre>curl -X POST http://localhost:5000/api/jobs \\\\\n  -H \"Content-Type: application/json\" \\\\\n  -d '{\n    \"agent_name\": \"YourAgentName\",\n    \"description\": \"a cute robot with LED eyes\",\n    \"style\": \"figurine\",\n    \"size_mm\": 50\n  }'</pre>\n        \n        <h3>Check Job Status</h3>\n        <pre>curl http://localhost:5000/api/jobs/{job_id}</pre>\n        \n        <h3>List Your Jobs</h3>\n        <pre>curl \"http://localhost:5000/api/jobs?agent_name=YourAgentName\"</pre>\n        \n        <p><strong>Styles:</strong> <code>figurine</code>, <code>sculpture</code>, <code>object</code>, <code>character</code></p>\n        <p><strong>Size Range:</strong> 20-200mm recommended</p>\n    </div>\n</body>\n</html>\n    \"\"\"\n    \n    return render_template_string(dashboard_html, stats=stats, recent_jobs=recent_jobs)\n\n@app.route('/api/jobs', methods=['POST'])\ndef submit_job():\n    \"\"\"Submit a new 3D printing job\"\"\"\n    data = request.get_json()\n    \n    # Validate required fields\n    required = ['agent_name', 'description']\n    if not all(field in data for field in required):\n        return jsonify({\"error\": \"Missing required fields\", \"required\": required}), 400\n    \n    # Extract parameters\n    agent_name = data['agent_name']\n    description = data['description']\n    style = data.get('style', 'figurine')\n    size_mm = data.get('size_mm', 50.0)\n    \n    # Validate parameters\n    if not isinstance(size_mm, (int, float)) or size_mm < 10 or size_mm > 500:\n        return jsonify({\"error\": \"size_mm must be between 10 and 500\"}), 400\n    \n    if style not in ['figurine', 'sculpture', 'object', 'character']:\n        return jsonify({\"error\": \"style must be one of: figurine, sculpture, object, character\"}), 400\n    \n    # Submit job\n    job_id = service.submit_job(agent_name, description, style, size_mm)\n    \n    return jsonify({\n        \"success\": True,\n        \"job_id\": job_id,\n        \"message\": \"Job submitted successfully\",\n        \"status_url\": f\"/api/jobs/{job_id}\"\n    }), 201\n\n@app.route('/api/jobs/<job_id>')\ndef get_job(job_id):\n    \"\"\"Get job status and results\"\"\"\n    job = service.get_job_status(job_id)\n    \n    if not job:\n        return jsonify({\"error\": \"Job not found\"}), 404\n    \n    return jsonify(job)\n\n@app.route('/api/jobs')\ndef list_jobs():\n    \"\"\"List jobs, optionally filtered by agent\"\"\"\n    agent_name = request.args.get('agent_name')\n    limit = int(request.args.get('limit', 20))\n    \n    jobs = service.list_jobs(agent_name, limit)\n    \n    return jsonify({\"jobs\": jobs, \"total\": len(jobs)})\n\n@app.route('/api/stats')\ndef get_stats():\n    \"\"\"Get service statistics\"\"\"\n    return jsonify(service.get_stats())\n\ndef main():\n    \"\"\"Start the service\"\"\"\n    print(\"üñ®Ô∏è Starting AI Agent 3D Printing Service\")\n    print(\"üåê Dashboard: http://localhost:5000\")\n    print(\"üîå API: http://localhost:5000/api/\")\n    print(\"-\" * 50)\n    \n    # Start the worker\n    service.start_worker()\n    \n    # Start Flask app\n    app.run(host='0.0.0.0', port=5000, debug=False)\n\nif __name__ == \"__main__\":\n    main()"}